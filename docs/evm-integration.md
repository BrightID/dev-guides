# EVM integration

BrightID supports clients uploading signed verifications to a smart contract that can then create a registry of verified users.

Each app (also called "context") manages its own registry. An "app" in BrightID can also represent a network or a platform.

This involves deploying a smart contract for the app  based on a BrightID smart contract template. This is useful if an app needs to check if someone is unique from within a smart contract rather than using code which can call `/verifications` on a BrightID node. A user’s client program initially uses the `/verifications` endpoint with the `signed=eth` and `timestamp=seconds` parameters to prepare the verification to send to the smart contract’s `verify` function.

## Example code

Please see the [github repo](https://github.com/BrightID/BrightID-SmartContract) for templates that can be deployed per app as needed.

## Registering an Ethereum address as a unique human

The `verify` function takes the signed data returned from the `/verifications` endpoint as input. It checks the signature using its registry of node public keys.

It checks that the most recent `contextId` + `context` wasn’t previously used and if not, links it to the address of the message sender.

If there are previously used `contextIds` in the signed data returned from `/verifications`, the Ethereum addresses linked to them are combined into an array of previously-used Ethereum addresses and mapped to the message sender’s address.

## Possible flow for registering a unique human

1. A [uuid](https://www.ietf.org/rfc/rfc4122.txt) is generated by the client to use as a contextId.
2. The client creates a deep link using that contextId. This must be done on a mobile browser, since it opens the BrightID mobile application.
    * If the mobile browser isn’t Ethereum-capable, it can receive the uuid by scanning a QR code presented by the original client. Step 3 onward proceeds on the original client.
4. The client waits 5 seconds for the mapping to propagate to all BrightID nodes, then calls `/verifications`.
5. The client calls the register function of the smart contract using the result from `/verifications`.
6. Now the user can be looked up in the `verifications` and `history` mappings in a context’s smart contract.
